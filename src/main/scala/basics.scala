
// объявление констант
// аналог на java: final int i = 0;
// ";" не является обазательной
val i: Int = 0
// объявление переменных
// аналог на java: int j = 0;
var j: Int = 0

// в скала мошьная система вывиедения типов, поэтому зачастую указать тип переменных не обязательно:
val k = 0
var str = ""

// в скала всё является объектом (но компилятор, по возможности, использует примитивные типы), по этому можно написать так
// здесь же продемонстрировано то, что для методов которые не принимают параметры скобки не обязательны
val numStr = 0.toString
// но настоятельно их использовать для методов с сайд эффектами (void):
println // так компиляется, но Идея ругается
println()

// объявление функций и методов:
def foo(a: String): Int = {
  // ключевое слово return не обязательно и его использование не преветсвуется
  // так же в scala можно свободно использовать java-классы
  Integer.parseInt(a)
}

// для методов так же работает выведение типов, плюс если метод состоит из одного выражения, то скобки можно опустить
// я для себя пока что выробатал политику, что выводом типов стоит пользоваться только для локальных переменных и функций,
// всё что является членом класса (в том числе и закрытым), должно иметь явно указанный тип
def bar(a: String) = Integer.parseInt(a)

// void-методы имеют тип юнит, но для них рекомендуется не указывать тип и не использовать знак "=":
def baz() {
}

def bac(): Unit = { // так тоже можно, но Идея ругается
}


// условные выражения в scala, обычные, за исключениме того, что они именно выражения
// стоит ли так писать я для себя ещё не решил, но пока что склоняюсь, что только стоит использовать для методов состоящих
// только из условия
val a = 0
val sign = if (a == 0) {
  0
} else if (a > 0) {
  1
} else {
  -1
}

// Императивный аналог (и тут не работает вывод типа для sign2):
var sign2: Int
if (a == 0) {
  sign2 = 0
} else if (a > 0) {
  sign2 = 1
} else {
  sign2 = -1
}

// так же в scala есть мощнейшая конструкция паттерн матчинга
// в отличае от обычного явавского свитча, в скала всегда выполняется ровно одинкейс и брейки не нужны
val sign3 = a match {
  case pos if pos > 0 => 1
  case zero if zero == 0 => 0
  case neg if neg < 0 => -1
}

// если метод имеет только один параметр и состоит только из конструкции матчинга, то ключевое слово match можно опустить:
def sign(a: Int): Int = a match {
  case pos if pos > 0 => 1
  case zero if zero == 0 => 0
  case neg if neg < 0 => -1
}

// её же можно использовать для проверки типов. Так же здесь приведён пример кейса по умолчанию: _

// AnyRef это что-то типа Object в java, иерархию рассмотрим позже
var d: AnyRef
val e = d match {
  case int: Int => int
  case str: String => Integer.parseInt(str)
  case _ => throw IllegalArgumentException
}

// То же касается и блоков try, плюс в catch'е используется паттерн матчинг
val num = try {
  Integer.parseInt(str)
} catch {
  case NumberFormatException => 0
  case RuntimeException => 1
}

// так же в скале есть старые добрые императивные вайлы:
var m = 0
while (m < 10) {
  println(m)
  m += 1 // в скала нет привычного ++
}

// а вот родного фора нету. Чтобы с имитировать for (int i = 0; i < 10; i++) надо писать так
// to - это не ключевое слово. с for-ом надо быть осторожнее он компилируется в кое-какой ад и его мы расстрим позже
for (i <- 0 to 10) {
  println(i)
}

// выше приведён пример того, что в скала запись: x.method(y) можно переписать, как x method y, т.е. 0 to 10 эквивалентно:
0.to(10)
// так же, в скале символы могут быть именами методов, поэтому выражение 0 + 1 на самом деле является
0.+(1) // - + это метод класса Int

// кортежи, они же таплы - типизированные наботы значений
val pair:(String, Int) = ("one", 1)
println(pair._1)
println(pair._2)

// Так же есть синтаксический сахар для возврата кортежей из функций
def getXY = (1, 2)

// язык может сам разобрать кортеж на x и y
val (x, y) = getXY
println(x)
println(y)

// это аналог страшной записи
val xy = getXY
println(xy._1)
println(xy._2)